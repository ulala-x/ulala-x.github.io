

// <auto-generated />

// this file must not be importing any namespaces
// we should use full names everywhere to avoid any potential naming conflicts, example: #1007, #778

// the namespace name must be in sync with WindowsDisassembler.BuildArguments
namespace BenchmarkDotNet.Autogenerated
{
    public class UniqueProgramName // we need different name than typical "Program" to avoid problems with referencing "Program" types from benchmarked code, #691
    {
        
        public static System.Int32 Main(System.String[] args)
        {
            // this method MUST NOT have any dependencies to BenchmarkDotNet and any other external dlls! (CoreRT is exception from this rule)
            // otherwise if LINQPad's shadow copy is enabled, we will not register for AssemblyLoading event
            // before .NET Framework tries to load it for this method
#if NETFRAMEWORK
            using(new DirtyAssemblyResolveHelper())
#endif
                return AfterAssemblyLoadingAttached(args);
        }

        private static System.Int32 AfterAssemblyLoadingAttached(System.String[] args)
        {
            BenchmarkDotNet.Engines.IHost host; // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it
            if (BenchmarkDotNet.Engines.AnonymousPipesHost.TryGetFileHandles(args, out System.String writeHandle, out System.String readHandle))
                host = new BenchmarkDotNet.Engines.AnonymousPipesHost(writeHandle, readHandle);
            else
                host = new BenchmarkDotNet.Engines.NoAcknowledgementConsoleHost();

            // the first thing to do is to let diagnosers hook in before anything happens
            // so all jit-related diagnosers can catch first jit compilation!
            BenchmarkDotNet.Engines.HostExtensions.BeforeAnythingElse(host);

            try
            {
                // we are not using Runnable here in any direct way in order to avoid strong dependency Main<=>Runnable
                // which could cause the jitting/assembly loading to happen before we do anything
                // we have some jitting diagnosers and we want them to catch all the informations!!

                // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it
                System.String benchmarkName = System.Linq.Enumerable.FirstOrDefault(System.Linq.Enumerable.Skip(System.Linq.Enumerable.SkipWhile(args, arg => arg != "--benchmarkName"), 1)) ?? "not provided";
                System.Int32 id = args.Length > 0
                    ? System.Int32.Parse(args[args.Length - 1]) // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it
                    : 0; // used when re-using generated exe without BDN (typically to repro a bug)

                if (args.Length == 0)
                {
                    host.WriteLine("You have not specified benchmark id (an integer) so the first benchmark will be executed.");
                }

#if NATIVEAOT
                
#else
                System.Type type = typeof(BenchmarkDotNet.Autogenerated.UniqueProgramName).Assembly.GetType($"BenchmarkDotNet.Autogenerated.Runnable_{id}");
                type.GetMethod("Run", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static).Invoke(null, new System.Object[] { host, benchmarkName });
#endif
                return 0;
            }
            catch (System.Exception oom) when (oom is System.OutOfMemoryException || oom is System.Reflection.TargetInvocationException reflection && reflection.InnerException is System.OutOfMemoryException)
            {
                host.WriteLine();
                host.WriteLine("OutOfMemoryException!");
                host.WriteLine("BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects.");
                host.WriteLine("If your benchmark allocates memory and keeps it alive, you are creating a memory leak.");
                host.WriteLine("You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that.");
                host.WriteLine();
                host.WriteLine(oom.ToString());

                return -1;
            }
            catch(System.Exception ex)
            {
                host.WriteLine();
                host.WriteLine(ex.ToString());
                return -1;
            }
            finally
            {
                BenchmarkDotNet.Engines.HostExtensions.AfterAll(host);

                host.Dispose();
            }
        }
    }

#if NETFRAMEWORK
    internal class DirtyAssemblyResolveHelper : System.IDisposable
    {
        internal DirtyAssemblyResolveHelper() => System.AppDomain.CurrentDomain.AssemblyResolve += HelpTheFrameworkToResolveTheAssembly;

        public void Dispose() => System.AppDomain.CurrentDomain.AssemblyResolve -= HelpTheFrameworkToResolveTheAssembly;

        /// <summary>
        /// according to https://msdn.microsoft.com/en-us/library/ff527268(v=vs.110).aspx
        /// "the handler is invoked whenever the runtime fails to bind to an assembly by name."
        /// </summary>
        /// <returns>not null when we find it manually, null when can't help</returns>
        private System.Reflection.Assembly HelpTheFrameworkToResolveTheAssembly(System.Object sender, System.ResolveEventArgs args)
        {
#if SHADOWCOPY // used for LINQPad
            const System.String shadowCopyFolderPath = @"";

            System.String guessedPath = System.IO.Path.Combine(shadowCopyFolderPath, $"{new System.Reflection.AssemblyName(args.Name).Name}.dll");

            return System.IO.File.Exists(guessedPath) ? System.Reflection.Assembly.LoadFrom(guessedPath) : null;
#else
            System.Reflection.AssemblyName fullName = new System.Reflection.AssemblyName(args.Name);
            System.String simpleName = fullName.Name;

            System.String guessedPath = System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, $"{simpleName}.dll");

            if (!System.IO.File.Exists(guessedPath))
            {
                System.Console.WriteLine($"// Wrong assembly binding redirects for {args.Name}.");
                return null; // we can't help, and we also don't call Assembly.Load which if fails comes back here, creates endless loop and causes StackOverflow
            }

            // the file is right there, but has most probably different version and there is no assembly binding redirect or there is a wrong one...
            // so we just load it and ignore the version mismatch

            // we warn the user about that, in case some Super User want to be aware of that
            System.Console.WriteLine($"// Wrong assembly binding redirects for {simpleName}, loading it from disk anyway.");

            return System.Reflection.Assembly.LoadFrom(guessedPath);
#endif // SHADOWCOPY
        }
    }
#endif // NETFRAMEWORK

        // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_0 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_0 instance = new BenchmarkDotNet.Autogenerated.Runnable_0(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_0()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = MarshalAllocHGlobal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_0.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_0.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                MarshalAllocHGlobal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_1 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_1 instance = new BenchmarkDotNet.Autogenerated.Runnable_1(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_1()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_1.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_1.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_2 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_2 instance = new BenchmarkDotNet.Autogenerated.Runnable_2(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_2()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_2.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_2.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_3 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_3 instance = new BenchmarkDotNet.Autogenerated.Runnable_3(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_3()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_3.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_3.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_4 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_4 instance = new BenchmarkDotNet.Autogenerated.Runnable_4(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_4()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_4.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_4.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_5 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_5 instance = new BenchmarkDotNet.Autogenerated.Runnable_5(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_5()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = MarshalAllocHGlobal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_5.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_5.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                MarshalAllocHGlobal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_6 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_6 instance = new BenchmarkDotNet.Autogenerated.Runnable_6(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_6()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_6.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_6.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_7 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_7 instance = new BenchmarkDotNet.Autogenerated.Runnable_7(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_7()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_7.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_7.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_8 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_8 instance = new BenchmarkDotNet.Autogenerated.Runnable_8(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_8()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_8.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_8.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_9 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_9 instance = new BenchmarkDotNet.Autogenerated.Runnable_9(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_9()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_9.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_9.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_10 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_10 instance = new BenchmarkDotNet.Autogenerated.Runnable_10(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_10()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = MarshalAllocHGlobal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_10.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_10.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                MarshalAllocHGlobal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_11 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_11 instance = new BenchmarkDotNet.Autogenerated.Runnable_11(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_11()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_11.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_11.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_12 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_12 instance = new BenchmarkDotNet.Autogenerated.Runnable_12(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_12()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_12.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_12.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_13 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_13 instance = new BenchmarkDotNet.Autogenerated.Runnable_13(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_13()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_13.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_13.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_14 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_14 instance = new BenchmarkDotNet.Autogenerated.Runnable_14(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_14()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_14.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_14.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_15 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_15 instance = new BenchmarkDotNet.Autogenerated.Runnable_15(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_15()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = MarshalAllocHGlobal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_15.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_15.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                MarshalAllocHGlobal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_16 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_16 instance = new BenchmarkDotNet.Autogenerated.Runnable_16(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_16()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_16.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_16.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_17 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_17 instance = new BenchmarkDotNet.Autogenerated.Runnable_17(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_17()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_17.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_17.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_18 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_18 instance = new BenchmarkDotNet.Autogenerated.Runnable_18(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_18()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_18.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_18.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_19 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_19 instance = new BenchmarkDotNet.Autogenerated.Runnable_19(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_19()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_19.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_19.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_20 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_20 instance = new BenchmarkDotNet.Autogenerated.Runnable_20(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_20()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = MarshalAllocHGlobal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_20.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_20.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                MarshalAllocHGlobal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_21 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_21 instance = new BenchmarkDotNet.Autogenerated.Runnable_21(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_21()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_21.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_21.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_22 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_22 instance = new BenchmarkDotNet.Autogenerated.Runnable_22(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_22()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_22.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_22.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_23 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_23 instance = new BenchmarkDotNet.Autogenerated.Runnable_23(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_23()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_23.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_23.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_24 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_24 instance = new BenchmarkDotNet.Autogenerated.Runnable_24(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_24()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_24.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_24.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_25 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_25 instance = new BenchmarkDotNet.Autogenerated.Runnable_25(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_25()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = MarshalAllocHGlobal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_25.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_25.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                MarshalAllocHGlobal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_26 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_26 instance = new BenchmarkDotNet.Autogenerated.Runnable_26(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_26()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_26.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_26.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_27 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_27 instance = new BenchmarkDotNet.Autogenerated.Runnable_27(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_27()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_27.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_27.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_28 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_28 instance = new BenchmarkDotNet.Autogenerated.Runnable_28(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_28()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_28.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_28.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_29 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_29 instance = new BenchmarkDotNet.Autogenerated.Runnable_29(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_29()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_29.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_29.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_30 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_30 instance = new BenchmarkDotNet.Autogenerated.Runnable_30(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_30()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = MarshalAllocHGlobal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_30.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_30.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                MarshalAllocHGlobal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_31 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_31 instance = new BenchmarkDotNet.Autogenerated.Runnable_31(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_31()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_31.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_31.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_32 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_32 instance = new BenchmarkDotNet.Autogenerated.Runnable_32(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_32()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_32.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_32.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_33 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_33 instance = new BenchmarkDotNet.Autogenerated.Runnable_33(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_33()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_33.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_33.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_34 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_34 instance = new BenchmarkDotNet.Autogenerated.Runnable_34(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_34()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_34.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_34.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_35 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_35 instance = new BenchmarkDotNet.Autogenerated.Runnable_35(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_35()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = MarshalAllocHGlobal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_35.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_35.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                MarshalAllocHGlobal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_36 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_36 instance = new BenchmarkDotNet.Autogenerated.Runnable_36(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_36()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_36.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_36.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_37 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_37 instance = new BenchmarkDotNet.Autogenerated.Runnable_37(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_37()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_37.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_37.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_38 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_38 instance = new BenchmarkDotNet.Autogenerated.Runnable_38(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_38()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_38.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_38.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_39 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_39 instance = new BenchmarkDotNet.Autogenerated.Runnable_39(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_39()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_39.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_39.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_40 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_40 instance = new BenchmarkDotNet.Autogenerated.Runnable_40(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_40()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = MarshalAllocHGlobal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_40.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_40.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                MarshalAllocHGlobal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_41 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_41 instance = new BenchmarkDotNet.Autogenerated.Runnable_41(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_41()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_41.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_41.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_42 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_42 instance = new BenchmarkDotNet.Autogenerated.Runnable_42(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_42()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_42.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_42.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_43 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_43 instance = new BenchmarkDotNet.Autogenerated.Runnable_43(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_43()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_43.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_43.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_44 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_44 instance = new BenchmarkDotNet.Autogenerated.Runnable_44(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_44()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_44.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_44.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_45 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_45 instance = new BenchmarkDotNet.Autogenerated.Runnable_45(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_45()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = MarshalAllocHGlobal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_45.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_45.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                MarshalAllocHGlobal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_46 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_46 instance = new BenchmarkDotNet.Autogenerated.Runnable_46(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_46()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_46.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_46.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_47 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_47 instance = new BenchmarkDotNet.Autogenerated.Runnable_47(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_47()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_47.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_47.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_48 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_48 instance = new BenchmarkDotNet.Autogenerated.Runnable_48(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_48()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_48.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_48.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_49 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_49 instance = new BenchmarkDotNet.Autogenerated.Runnable_49(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_49()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_49.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_49.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_50 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_50 instance = new BenchmarkDotNet.Autogenerated.Runnable_50(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_50()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = MarshalAllocHGlobal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_50.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_50.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                MarshalAllocHGlobal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_51 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_51 instance = new BenchmarkDotNet.Autogenerated.Runnable_51(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_51()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_51.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_51.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_52 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_52 instance = new BenchmarkDotNet.Autogenerated.Runnable_52(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_52()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_52.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_52.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_53 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_53 instance = new BenchmarkDotNet.Autogenerated.Runnable_53(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_53()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_53.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_53.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_54 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_54 instance = new BenchmarkDotNet.Autogenerated.Runnable_54(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_54()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_54.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_54.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_55 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_55 instance = new BenchmarkDotNet.Autogenerated.Runnable_55(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_55()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = MarshalAllocHGlobal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_55.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_55.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                MarshalAllocHGlobal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_56 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_56 instance = new BenchmarkDotNet.Autogenerated.Runnable_56(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_56()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_56.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_56.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_57 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_57 instance = new BenchmarkDotNet.Autogenerated.Runnable_57(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_57()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeMemoryAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_57.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_57.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeMemoryAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_58 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_58 instance = new BenchmarkDotNet.Autogenerated.Runnable_58(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_58()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAlloc;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_58.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_58.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAlloc();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_59 : global::NativeMemory.Benchmarks.Benchmarks.AllocationBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_59 instance = new BenchmarkDotNet.Autogenerated.Runnable_59(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_59()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = StackAllocZeroed;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_59.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_59.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                StackAllocZeroed();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_60 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_60 instance = new BenchmarkDotNet.Autogenerated.Runnable_60(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_60()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_ArrayCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_60.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_60.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_ArrayCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_61 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_61 instance = new BenchmarkDotNet.Autogenerated.Runnable_61(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_61()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_61.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_61.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_62 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_62 instance = new BenchmarkDotNet.Autogenerated.Runnable_62(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_62()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_62.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_62.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_63 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_63 instance = new BenchmarkDotNet.Autogenerated.Runnable_63(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_63()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_63.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_63.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_64 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_64 instance = new BenchmarkDotNet.Autogenerated.Runnable_64(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_64()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_64.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_64.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_65 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_65 instance = new BenchmarkDotNet.Autogenerated.Runnable_65(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_65()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_65.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_65.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_66 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_66 instance = new BenchmarkDotNet.Autogenerated.Runnable_66(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_66()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_66.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_66.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_67 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_67 instance = new BenchmarkDotNet.Autogenerated.Runnable_67(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_67()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_67.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_67.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_68 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_68 instance = new BenchmarkDotNet.Autogenerated.Runnable_68(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_68()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_68.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_68.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_69 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_69 instance = new BenchmarkDotNet.Autogenerated.Runnable_69(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_69()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_UnsafeCopyBlock;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_69.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_69.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_UnsafeCopyBlock();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_70 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_70 instance = new BenchmarkDotNet.Autogenerated.Runnable_70(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_70()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ZeroCopy_FixedPointerPass;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_70.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_70.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ZeroCopy_FixedPointerPass();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_71 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_71 instance = new BenchmarkDotNet.Autogenerated.Runnable_71(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_71()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RoundTrip_ManagedNativeManaged;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_71.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_71.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                RoundTrip_ManagedNativeManaged();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_72 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_72 instance = new BenchmarkDotNet.Autogenerated.Runnable_72(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_72()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = BatchTransfer_MultipleManagedToNative;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_72.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_72.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                BatchTransfer_MultipleManagedToNative();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_73 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_73 instance = new BenchmarkDotNet.Autogenerated.Runnable_73(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_73()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_ArrayCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_73.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_73.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_ArrayCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_74 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_74 instance = new BenchmarkDotNet.Autogenerated.Runnable_74(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_74()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_74.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_74.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_75 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_75 instance = new BenchmarkDotNet.Autogenerated.Runnable_75(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_75()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_75.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_75.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_76 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_76 instance = new BenchmarkDotNet.Autogenerated.Runnable_76(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_76()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_76.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_76.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_77 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_77 instance = new BenchmarkDotNet.Autogenerated.Runnable_77(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_77()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_77.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_77.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_78 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_78 instance = new BenchmarkDotNet.Autogenerated.Runnable_78(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_78()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_78.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_78.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_79 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_79 instance = new BenchmarkDotNet.Autogenerated.Runnable_79(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_79()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_79.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_79.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_80 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_80 instance = new BenchmarkDotNet.Autogenerated.Runnable_80(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_80()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_80.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_80.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_81 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_81 instance = new BenchmarkDotNet.Autogenerated.Runnable_81(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_81()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_81.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_81.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_82 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_82 instance = new BenchmarkDotNet.Autogenerated.Runnable_82(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_82()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_UnsafeCopyBlock;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_82.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_82.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_UnsafeCopyBlock();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_83 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_83 instance = new BenchmarkDotNet.Autogenerated.Runnable_83(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_83()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ZeroCopy_FixedPointerPass;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_83.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_83.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ZeroCopy_FixedPointerPass();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_84 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_84 instance = new BenchmarkDotNet.Autogenerated.Runnable_84(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_84()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RoundTrip_ManagedNativeManaged;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_84.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_84.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                RoundTrip_ManagedNativeManaged();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_85 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_85 instance = new BenchmarkDotNet.Autogenerated.Runnable_85(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_85()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = BatchTransfer_MultipleManagedToNative;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_85.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_85.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                BatchTransfer_MultipleManagedToNative();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_86 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_86 instance = new BenchmarkDotNet.Autogenerated.Runnable_86(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_86()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_ArrayCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_86.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_86.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_ArrayCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_87 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_87 instance = new BenchmarkDotNet.Autogenerated.Runnable_87(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_87()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_87.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_87.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_88 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_88 instance = new BenchmarkDotNet.Autogenerated.Runnable_88(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_88()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_88.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_88.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_89 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_89 instance = new BenchmarkDotNet.Autogenerated.Runnable_89(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_89()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_89.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_89.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_90 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_90 instance = new BenchmarkDotNet.Autogenerated.Runnable_90(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_90()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_90.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_90.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_91 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_91 instance = new BenchmarkDotNet.Autogenerated.Runnable_91(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_91()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_91.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_91.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_92 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_92 instance = new BenchmarkDotNet.Autogenerated.Runnable_92(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_92()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_92.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_92.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_93 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_93 instance = new BenchmarkDotNet.Autogenerated.Runnable_93(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_93()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_93.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_93.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_94 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_94 instance = new BenchmarkDotNet.Autogenerated.Runnable_94(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_94()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_94.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_94.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_95 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_95 instance = new BenchmarkDotNet.Autogenerated.Runnable_95(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_95()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_UnsafeCopyBlock;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_95.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_95.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_UnsafeCopyBlock();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_96 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_96 instance = new BenchmarkDotNet.Autogenerated.Runnable_96(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_96()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ZeroCopy_FixedPointerPass;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_96.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_96.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ZeroCopy_FixedPointerPass();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_97 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_97 instance = new BenchmarkDotNet.Autogenerated.Runnable_97(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_97()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RoundTrip_ManagedNativeManaged;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_97.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_97.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                RoundTrip_ManagedNativeManaged();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_98 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_98 instance = new BenchmarkDotNet.Autogenerated.Runnable_98(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_98()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = BatchTransfer_MultipleManagedToNative;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_98.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_98.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                BatchTransfer_MultipleManagedToNative();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_99 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_99 instance = new BenchmarkDotNet.Autogenerated.Runnable_99(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_99()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_ArrayCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_99.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_99.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_ArrayCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_100 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_100 instance = new BenchmarkDotNet.Autogenerated.Runnable_100(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_100()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_100.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_100.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_101 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_101 instance = new BenchmarkDotNet.Autogenerated.Runnable_101(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_101()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_101.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_101.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_102 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_102 instance = new BenchmarkDotNet.Autogenerated.Runnable_102(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_102()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_102.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_102.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_103 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_103 instance = new BenchmarkDotNet.Autogenerated.Runnable_103(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_103()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_103.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_103.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_104 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_104 instance = new BenchmarkDotNet.Autogenerated.Runnable_104(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_104()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_104.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_104.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_105 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_105 instance = new BenchmarkDotNet.Autogenerated.Runnable_105(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_105()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_105.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_105.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_106 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_106 instance = new BenchmarkDotNet.Autogenerated.Runnable_106(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_106()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_106.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_106.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_107 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_107 instance = new BenchmarkDotNet.Autogenerated.Runnable_107(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_107()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_107.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_107.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_108 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_108 instance = new BenchmarkDotNet.Autogenerated.Runnable_108(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_108()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_UnsafeCopyBlock;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_108.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_108.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_UnsafeCopyBlock();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_109 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_109 instance = new BenchmarkDotNet.Autogenerated.Runnable_109(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_109()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ZeroCopy_FixedPointerPass;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_109.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_109.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ZeroCopy_FixedPointerPass();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_110 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_110 instance = new BenchmarkDotNet.Autogenerated.Runnable_110(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_110()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RoundTrip_ManagedNativeManaged;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_110.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_110.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                RoundTrip_ManagedNativeManaged();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_111 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_111 instance = new BenchmarkDotNet.Autogenerated.Runnable_111(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_111()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = BatchTransfer_MultipleManagedToNative;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_111.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_111.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                BatchTransfer_MultipleManagedToNative();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_112 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_112 instance = new BenchmarkDotNet.Autogenerated.Runnable_112(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_112()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_ArrayCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_112.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_112.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_ArrayCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_113 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_113 instance = new BenchmarkDotNet.Autogenerated.Runnable_113(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_113()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_113.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_113.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_114 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_114 instance = new BenchmarkDotNet.Autogenerated.Runnable_114(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_114()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_114.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_114.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_115 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_115 instance = new BenchmarkDotNet.Autogenerated.Runnable_115(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_115()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_115.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_115.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_116 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_116 instance = new BenchmarkDotNet.Autogenerated.Runnable_116(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_116()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_116.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_116.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_117 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_117 instance = new BenchmarkDotNet.Autogenerated.Runnable_117(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_117()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_117.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_117.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_118 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_118 instance = new BenchmarkDotNet.Autogenerated.Runnable_118(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_118()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_118.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_118.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_119 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_119 instance = new BenchmarkDotNet.Autogenerated.Runnable_119(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_119()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_119.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_119.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_120 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_120 instance = new BenchmarkDotNet.Autogenerated.Runnable_120(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_120()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_120.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_120.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_121 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_121 instance = new BenchmarkDotNet.Autogenerated.Runnable_121(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_121()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_UnsafeCopyBlock;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_121.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_121.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_UnsafeCopyBlock();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_122 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_122 instance = new BenchmarkDotNet.Autogenerated.Runnable_122(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_122()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ZeroCopy_FixedPointerPass;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_122.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_122.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ZeroCopy_FixedPointerPass();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_123 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_123 instance = new BenchmarkDotNet.Autogenerated.Runnable_123(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_123()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RoundTrip_ManagedNativeManaged;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_123.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_123.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                RoundTrip_ManagedNativeManaged();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_124 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_124 instance = new BenchmarkDotNet.Autogenerated.Runnable_124(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_124()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = BatchTransfer_MultipleManagedToNative;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_124.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_124.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                BatchTransfer_MultipleManagedToNative();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_125 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_125 instance = new BenchmarkDotNet.Autogenerated.Runnable_125(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_125()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_ArrayCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_125.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_125.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_ArrayCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_126 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_126 instance = new BenchmarkDotNet.Autogenerated.Runnable_126(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_126()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_126.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_126.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_127 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_127 instance = new BenchmarkDotNet.Autogenerated.Runnable_127(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_127()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_127.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_127.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_128 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_128 instance = new BenchmarkDotNet.Autogenerated.Runnable_128(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_128()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_128.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_128.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_129 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_129 instance = new BenchmarkDotNet.Autogenerated.Runnable_129(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_129()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_129.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_129.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_130 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_130 instance = new BenchmarkDotNet.Autogenerated.Runnable_130(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_130()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_130.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_130.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_131 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_131 instance = new BenchmarkDotNet.Autogenerated.Runnable_131(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_131()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_131.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_131.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_132 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_132 instance = new BenchmarkDotNet.Autogenerated.Runnable_132(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_132()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_132.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_132.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_133 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_133 instance = new BenchmarkDotNet.Autogenerated.Runnable_133(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_133()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_133.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_133.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_134 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_134 instance = new BenchmarkDotNet.Autogenerated.Runnable_134(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_134()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_UnsafeCopyBlock;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_134.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_134.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_UnsafeCopyBlock();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_135 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_135 instance = new BenchmarkDotNet.Autogenerated.Runnable_135(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_135()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ZeroCopy_FixedPointerPass;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_135.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_135.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ZeroCopy_FixedPointerPass();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_136 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_136 instance = new BenchmarkDotNet.Autogenerated.Runnable_136(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_136()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RoundTrip_ManagedNativeManaged;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_136.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_136.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                RoundTrip_ManagedNativeManaged();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_137 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_137 instance = new BenchmarkDotNet.Autogenerated.Runnable_137(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_137()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = BatchTransfer_MultipleManagedToNative;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_137.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_137.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                BatchTransfer_MultipleManagedToNative();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_138 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_138 instance = new BenchmarkDotNet.Autogenerated.Runnable_138(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_138()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_ArrayCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_138.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_138.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_ArrayCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_139 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_139 instance = new BenchmarkDotNet.Autogenerated.Runnable_139(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_139()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_139.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_139.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_140 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_140 instance = new BenchmarkDotNet.Autogenerated.Runnable_140(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_140()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_140.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_140.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_141 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_141 instance = new BenchmarkDotNet.Autogenerated.Runnable_141(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_141()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_141.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_141.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_142 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_142 instance = new BenchmarkDotNet.Autogenerated.Runnable_142(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_142()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_142.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_142.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_143 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_143 instance = new BenchmarkDotNet.Autogenerated.Runnable_143(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_143()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_143.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_143.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_144 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_144 instance = new BenchmarkDotNet.Autogenerated.Runnable_144(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_144()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_144.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_144.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_145 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_145 instance = new BenchmarkDotNet.Autogenerated.Runnable_145(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_145()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_145.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_145.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_146 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_146 instance = new BenchmarkDotNet.Autogenerated.Runnable_146(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_146()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_146.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_146.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_147 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_147 instance = new BenchmarkDotNet.Autogenerated.Runnable_147(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_147()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_UnsafeCopyBlock;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_147.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_147.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_UnsafeCopyBlock();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_148 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_148 instance = new BenchmarkDotNet.Autogenerated.Runnable_148(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_148()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ZeroCopy_FixedPointerPass;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_148.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_148.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ZeroCopy_FixedPointerPass();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_149 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_149 instance = new BenchmarkDotNet.Autogenerated.Runnable_149(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_149()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RoundTrip_ManagedNativeManaged;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_149.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_149.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                RoundTrip_ManagedNativeManaged();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_150 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_150 instance = new BenchmarkDotNet.Autogenerated.Runnable_150(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_150()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = BatchTransfer_MultipleManagedToNative;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_150.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_150.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                BatchTransfer_MultipleManagedToNative();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_151 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_151 instance = new BenchmarkDotNet.Autogenerated.Runnable_151(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_151()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_ArrayCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_151.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_151.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_ArrayCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_152 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_152 instance = new BenchmarkDotNet.Autogenerated.Runnable_152(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_152()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_152.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_152.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_153 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_153 instance = new BenchmarkDotNet.Autogenerated.Runnable_153(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_153()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_153.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_153.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_154 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_154 instance = new BenchmarkDotNet.Autogenerated.Runnable_154(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_154()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_154.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_154.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_155 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_155 instance = new BenchmarkDotNet.Autogenerated.Runnable_155(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_155()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_155.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_155.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_156 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_156 instance = new BenchmarkDotNet.Autogenerated.Runnable_156(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_156()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_156.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_156.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_157 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_157 instance = new BenchmarkDotNet.Autogenerated.Runnable_157(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_157()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_157.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_157.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_158 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_158 instance = new BenchmarkDotNet.Autogenerated.Runnable_158(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_158()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_158.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_158.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_159 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_159 instance = new BenchmarkDotNet.Autogenerated.Runnable_159(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_159()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_159.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_159.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_160 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_160 instance = new BenchmarkDotNet.Autogenerated.Runnable_160(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_160()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_UnsafeCopyBlock;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_160.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_160.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_UnsafeCopyBlock();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_161 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_161 instance = new BenchmarkDotNet.Autogenerated.Runnable_161(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_161()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ZeroCopy_FixedPointerPass;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_161.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_161.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ZeroCopy_FixedPointerPass();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_162 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_162 instance = new BenchmarkDotNet.Autogenerated.Runnable_162(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_162()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RoundTrip_ManagedNativeManaged;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_162.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_162.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                RoundTrip_ManagedNativeManaged();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_163 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_163 instance = new BenchmarkDotNet.Autogenerated.Runnable_163(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_163()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = BatchTransfer_MultipleManagedToNative;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_163.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_163.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                BatchTransfer_MultipleManagedToNative();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_164 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_164 instance = new BenchmarkDotNet.Autogenerated.Runnable_164(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_164()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_ArrayCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_164.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_164.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_ArrayCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_165 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_165 instance = new BenchmarkDotNet.Autogenerated.Runnable_165(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_165()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_165.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_165.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_166 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_166 instance = new BenchmarkDotNet.Autogenerated.Runnable_166(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_166()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_166.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_166.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_167 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_167 instance = new BenchmarkDotNet.Autogenerated.Runnable_167(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_167()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_167.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_167.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_168 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_168 instance = new BenchmarkDotNet.Autogenerated.Runnable_168(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_168()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_168.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_168.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_169 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_169 instance = new BenchmarkDotNet.Autogenerated.Runnable_169(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_169()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_169.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_169.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_170 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_170 instance = new BenchmarkDotNet.Autogenerated.Runnable_170(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_170()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_170.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_170.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_171 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_171 instance = new BenchmarkDotNet.Autogenerated.Runnable_171(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_171()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_171.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_171.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_172 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_172 instance = new BenchmarkDotNet.Autogenerated.Runnable_172(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_172()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_172.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_172.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_173 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_173 instance = new BenchmarkDotNet.Autogenerated.Runnable_173(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_173()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_UnsafeCopyBlock;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_173.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_173.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_UnsafeCopyBlock();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_174 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_174 instance = new BenchmarkDotNet.Autogenerated.Runnable_174(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_174()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ZeroCopy_FixedPointerPass;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_174.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_174.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ZeroCopy_FixedPointerPass();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_175 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_175 instance = new BenchmarkDotNet.Autogenerated.Runnable_175(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_175()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RoundTrip_ManagedNativeManaged;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_175.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_175.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                RoundTrip_ManagedNativeManaged();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_176 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_176 instance = new BenchmarkDotNet.Autogenerated.Runnable_176(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_176()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = BatchTransfer_MultipleManagedToNative;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_176.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_176.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                BatchTransfer_MultipleManagedToNative();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_177 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_177 instance = new BenchmarkDotNet.Autogenerated.Runnable_177(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_177()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_ArrayCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_177.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_177.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_ArrayCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_178 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_178 instance = new BenchmarkDotNet.Autogenerated.Runnable_178(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_178()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_178.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_178.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_179 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_179 instance = new BenchmarkDotNet.Autogenerated.Runnable_179(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_179()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_179.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_179.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_180 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_180 instance = new BenchmarkDotNet.Autogenerated.Runnable_180(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_180()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_180.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_180.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_181 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_181 instance = new BenchmarkDotNet.Autogenerated.Runnable_181(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_181()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_181.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_181.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_182 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_182 instance = new BenchmarkDotNet.Autogenerated.Runnable_182(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_182()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_182.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_182.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_183 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_183 instance = new BenchmarkDotNet.Autogenerated.Runnable_183(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_183()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_183.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_183.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_184 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_184 instance = new BenchmarkDotNet.Autogenerated.Runnable_184(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_184()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_184.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_184.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_185 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_185 instance = new BenchmarkDotNet.Autogenerated.Runnable_185(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_185()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_185.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_185.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_186 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_186 instance = new BenchmarkDotNet.Autogenerated.Runnable_186(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_186()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_UnsafeCopyBlock;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_186.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_186.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_UnsafeCopyBlock();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_187 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_187 instance = new BenchmarkDotNet.Autogenerated.Runnable_187(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_187()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ZeroCopy_FixedPointerPass;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_187.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_187.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ZeroCopy_FixedPointerPass();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_188 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_188 instance = new BenchmarkDotNet.Autogenerated.Runnable_188(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_188()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RoundTrip_ManagedNativeManaged;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_188.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_188.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                RoundTrip_ManagedNativeManaged();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_189 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_189 instance = new BenchmarkDotNet.Autogenerated.Runnable_189(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_189()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = BatchTransfer_MultipleManagedToNative;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_189.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_189.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                BatchTransfer_MultipleManagedToNative();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_190 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_190 instance = new BenchmarkDotNet.Autogenerated.Runnable_190(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_190()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_ArrayCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_190.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_190.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_ArrayCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_191 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_191 instance = new BenchmarkDotNet.Autogenerated.Runnable_191(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_191()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_191.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_191.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_192 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_192 instance = new BenchmarkDotNet.Autogenerated.Runnable_192(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_192()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_192.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_192.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_193 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_193 instance = new BenchmarkDotNet.Autogenerated.Runnable_193(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_193()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_193.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_193.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_194 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_194 instance = new BenchmarkDotNet.Autogenerated.Runnable_194(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_194()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_194.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_194.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_195 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_195 instance = new BenchmarkDotNet.Autogenerated.Runnable_195(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_195()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_195.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_195.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_196 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_196 instance = new BenchmarkDotNet.Autogenerated.Runnable_196(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_196()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_196.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_196.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_197 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_197 instance = new BenchmarkDotNet.Autogenerated.Runnable_197(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_197()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_197.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_197.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_198 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_198 instance = new BenchmarkDotNet.Autogenerated.Runnable_198(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_198()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_198.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_198.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_199 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_199 instance = new BenchmarkDotNet.Autogenerated.Runnable_199(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_199()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_UnsafeCopyBlock;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_199.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_199.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_UnsafeCopyBlock();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_200 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_200 instance = new BenchmarkDotNet.Autogenerated.Runnable_200(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_200()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ZeroCopy_FixedPointerPass;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_200.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_200.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ZeroCopy_FixedPointerPass();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_201 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_201 instance = new BenchmarkDotNet.Autogenerated.Runnable_201(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_201()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RoundTrip_ManagedNativeManaged;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_201.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_201.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                RoundTrip_ManagedNativeManaged();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_202 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_202 instance = new BenchmarkDotNet.Autogenerated.Runnable_202(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_202()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = BatchTransfer_MultipleManagedToNative;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_202.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_202.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                BatchTransfer_MultipleManagedToNative();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_203 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_203 instance = new BenchmarkDotNet.Autogenerated.Runnable_203(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_203()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_ArrayCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_203.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_203.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_ArrayCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_204 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_204 instance = new BenchmarkDotNet.Autogenerated.Runnable_204(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_204()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_204.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_204.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_205 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_205 instance = new BenchmarkDotNet.Autogenerated.Runnable_205(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_205()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_205.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_205.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_206 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_206 instance = new BenchmarkDotNet.Autogenerated.Runnable_206(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_206()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_206.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_206.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_207 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_207 instance = new BenchmarkDotNet.Autogenerated.Runnable_207(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_207()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_207.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_207.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_208 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_208 instance = new BenchmarkDotNet.Autogenerated.Runnable_208(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_208()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ManagedToNative_SpanCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_208.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_208.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ManagedToNative_SpanCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_209 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_209 instance = new BenchmarkDotNet.Autogenerated.Runnable_209(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_209()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_MarshalCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_209.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_209.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_MarshalCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_210 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_210 instance = new BenchmarkDotNet.Autogenerated.Runnable_210(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_210()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToManaged_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_210.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_210.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToManaged_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_211 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_211 instance = new BenchmarkDotNet.Autogenerated.Runnable_211(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_211()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_BufferMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_211.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_211.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_BufferMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_212 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_212 instance = new BenchmarkDotNet.Autogenerated.Runnable_212(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_212()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = NativeToNative_UnsafeCopyBlock;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_212.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_212.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                NativeToNative_UnsafeCopyBlock();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_213 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_213 instance = new BenchmarkDotNet.Autogenerated.Runnable_213(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_213()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = ZeroCopy_FixedPointerPass;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_213.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_213.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                ZeroCopy_FixedPointerPass();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_214 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_214 instance = new BenchmarkDotNet.Autogenerated.Runnable_214(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_214()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RoundTrip_ManagedNativeManaged;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_214.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_214.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                RoundTrip_ManagedNativeManaged();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_215 : global::NativeMemory.Benchmarks.Benchmarks.DataTransferBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_215 instance = new BenchmarkDotNet.Autogenerated.Runnable_215(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_215()
        {
            globalSetupAction = Setup;
            globalCleanupAction = Cleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = BatchTransfer_MultipleManagedToNative;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_215.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_215.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                BatchTransfer_MultipleManagedToNative();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_216 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_216 instance = new BenchmarkDotNet.Autogenerated.Runnable_216(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_216()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedKeyword;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_216.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_216.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedKeyword();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_217 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_217 instance = new BenchmarkDotNet.Autogenerated.Runnable_217(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_217()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandlePinned;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_217.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_217.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandlePinned();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_218 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_218 instance = new BenchmarkDotNet.Autogenerated.Runnable_218(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_218()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanWithMemoryMarshal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_218.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_218.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanWithMemoryMarshal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_219 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_219 instance = new BenchmarkDotNet.Autogenerated.Runnable_219(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_219()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_219.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_219.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_220 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_220 instance = new BenchmarkDotNet.Autogenerated.Runnable_220(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_220()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanCopyTo;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_220.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_220.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanCopyTo();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_221 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_221 instance = new BenchmarkDotNet.Autogenerated.Runnable_221(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_221()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithNativeCall;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_221.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_221.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithNativeCall();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_222 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_222 instance = new BenchmarkDotNet.Autogenerated.Runnable_222(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_222()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandleLongLived;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_222.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_222.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandleLongLived();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_223 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_223 instance = new BenchmarkDotNet.Autogenerated.Runnable_223(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_223()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedKeyword;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_223.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_223.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedKeyword();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_224 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_224 instance = new BenchmarkDotNet.Autogenerated.Runnable_224(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_224()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandlePinned;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_224.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_224.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandlePinned();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_225 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_225 instance = new BenchmarkDotNet.Autogenerated.Runnable_225(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_225()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanWithMemoryMarshal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_225.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_225.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanWithMemoryMarshal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_226 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_226 instance = new BenchmarkDotNet.Autogenerated.Runnable_226(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_226()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_226.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_226.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_227 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_227 instance = new BenchmarkDotNet.Autogenerated.Runnable_227(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_227()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanCopyTo;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_227.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_227.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanCopyTo();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_228 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_228 instance = new BenchmarkDotNet.Autogenerated.Runnable_228(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_228()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithNativeCall;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_228.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_228.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithNativeCall();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_229 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_229 instance = new BenchmarkDotNet.Autogenerated.Runnable_229(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 64;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_229()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandleLongLived;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_229.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_229.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandleLongLived();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_230 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_230 instance = new BenchmarkDotNet.Autogenerated.Runnable_230(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_230()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedKeyword;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_230.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_230.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedKeyword();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_231 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_231 instance = new BenchmarkDotNet.Autogenerated.Runnable_231(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_231()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandlePinned;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_231.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_231.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandlePinned();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_232 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_232 instance = new BenchmarkDotNet.Autogenerated.Runnable_232(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_232()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanWithMemoryMarshal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_232.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_232.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanWithMemoryMarshal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_233 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_233 instance = new BenchmarkDotNet.Autogenerated.Runnable_233(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_233()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_233.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_233.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_234 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_234 instance = new BenchmarkDotNet.Autogenerated.Runnable_234(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_234()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanCopyTo;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_234.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_234.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanCopyTo();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_235 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_235 instance = new BenchmarkDotNet.Autogenerated.Runnable_235(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_235()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithNativeCall;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_235.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_235.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithNativeCall();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_236 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_236 instance = new BenchmarkDotNet.Autogenerated.Runnable_236(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_236()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandleLongLived;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_236.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_236.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandleLongLived();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_237 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_237 instance = new BenchmarkDotNet.Autogenerated.Runnable_237(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_237()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedKeyword;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_237.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_237.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedKeyword();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_238 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_238 instance = new BenchmarkDotNet.Autogenerated.Runnable_238(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_238()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandlePinned;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_238.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_238.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandlePinned();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_239 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_239 instance = new BenchmarkDotNet.Autogenerated.Runnable_239(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_239()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanWithMemoryMarshal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_239.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_239.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanWithMemoryMarshal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_240 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_240 instance = new BenchmarkDotNet.Autogenerated.Runnable_240(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_240()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_240.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_240.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_241 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_241 instance = new BenchmarkDotNet.Autogenerated.Runnable_241(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_241()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanCopyTo;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_241.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_241.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanCopyTo();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_242 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_242 instance = new BenchmarkDotNet.Autogenerated.Runnable_242(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_242()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithNativeCall;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_242.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_242.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithNativeCall();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_243 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_243 instance = new BenchmarkDotNet.Autogenerated.Runnable_243(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 512;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_243()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandleLongLived;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_243.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_243.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandleLongLived();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_244 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_244 instance = new BenchmarkDotNet.Autogenerated.Runnable_244(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_244()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedKeyword;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_244.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_244.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedKeyword();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_245 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_245 instance = new BenchmarkDotNet.Autogenerated.Runnable_245(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_245()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandlePinned;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_245.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_245.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandlePinned();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_246 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_246 instance = new BenchmarkDotNet.Autogenerated.Runnable_246(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_246()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanWithMemoryMarshal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_246.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_246.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanWithMemoryMarshal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_247 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_247 instance = new BenchmarkDotNet.Autogenerated.Runnable_247(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_247()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_247.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_247.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_248 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_248 instance = new BenchmarkDotNet.Autogenerated.Runnable_248(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_248()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanCopyTo;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_248.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_248.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanCopyTo();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_249 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_249 instance = new BenchmarkDotNet.Autogenerated.Runnable_249(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_249()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithNativeCall;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_249.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_249.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithNativeCall();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_250 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_250 instance = new BenchmarkDotNet.Autogenerated.Runnable_250(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_250()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandleLongLived;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_250.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_250.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandleLongLived();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_251 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_251 instance = new BenchmarkDotNet.Autogenerated.Runnable_251(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_251()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedKeyword;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_251.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_251.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedKeyword();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_252 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_252 instance = new BenchmarkDotNet.Autogenerated.Runnable_252(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_252()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandlePinned;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_252.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_252.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandlePinned();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_253 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_253 instance = new BenchmarkDotNet.Autogenerated.Runnable_253(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_253()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanWithMemoryMarshal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_253.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_253.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanWithMemoryMarshal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_254 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_254 instance = new BenchmarkDotNet.Autogenerated.Runnable_254(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_254()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_254.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_254.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_255 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_255 instance = new BenchmarkDotNet.Autogenerated.Runnable_255(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_255()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanCopyTo;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_255.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_255.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanCopyTo();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_256 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_256 instance = new BenchmarkDotNet.Autogenerated.Runnable_256(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_256()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithNativeCall;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_256.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_256.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithNativeCall();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_257 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_257 instance = new BenchmarkDotNet.Autogenerated.Runnable_257(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1024;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_257()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandleLongLived;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_257.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_257.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandleLongLived();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_258 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_258 instance = new BenchmarkDotNet.Autogenerated.Runnable_258(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_258()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedKeyword;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_258.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_258.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedKeyword();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_259 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_259 instance = new BenchmarkDotNet.Autogenerated.Runnable_259(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_259()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandlePinned;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_259.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_259.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandlePinned();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_260 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_260 instance = new BenchmarkDotNet.Autogenerated.Runnable_260(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_260()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanWithMemoryMarshal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_260.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_260.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanWithMemoryMarshal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_261 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_261 instance = new BenchmarkDotNet.Autogenerated.Runnable_261(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_261()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_261.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_261.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_262 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_262 instance = new BenchmarkDotNet.Autogenerated.Runnable_262(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_262()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanCopyTo;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_262.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_262.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanCopyTo();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_263 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_263 instance = new BenchmarkDotNet.Autogenerated.Runnable_263(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_263()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithNativeCall;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_263.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_263.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithNativeCall();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_264 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_264 instance = new BenchmarkDotNet.Autogenerated.Runnable_264(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_264()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandleLongLived;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_264.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_264.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandleLongLived();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_265 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_265 instance = new BenchmarkDotNet.Autogenerated.Runnable_265(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_265()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedKeyword;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_265.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_265.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedKeyword();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_266 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_266 instance = new BenchmarkDotNet.Autogenerated.Runnable_266(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_266()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandlePinned;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_266.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_266.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandlePinned();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_267 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_267 instance = new BenchmarkDotNet.Autogenerated.Runnable_267(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_267()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanWithMemoryMarshal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_267.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_267.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanWithMemoryMarshal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_268 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_268 instance = new BenchmarkDotNet.Autogenerated.Runnable_268(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_268()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_268.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_268.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_269 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_269 instance = new BenchmarkDotNet.Autogenerated.Runnable_269(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_269()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanCopyTo;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_269.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_269.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanCopyTo();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_270 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_270 instance = new BenchmarkDotNet.Autogenerated.Runnable_270(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_270()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithNativeCall;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_270.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_270.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithNativeCall();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_271 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_271 instance = new BenchmarkDotNet.Autogenerated.Runnable_271(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 4096;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_271()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandleLongLived;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_271.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_271.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandleLongLived();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_272 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_272 instance = new BenchmarkDotNet.Autogenerated.Runnable_272(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_272()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedKeyword;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_272.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_272.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedKeyword();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_273 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_273 instance = new BenchmarkDotNet.Autogenerated.Runnable_273(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_273()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandlePinned;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_273.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_273.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandlePinned();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_274 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_274 instance = new BenchmarkDotNet.Autogenerated.Runnable_274(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_274()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanWithMemoryMarshal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_274.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_274.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanWithMemoryMarshal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_275 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_275 instance = new BenchmarkDotNet.Autogenerated.Runnable_275(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_275()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_275.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_275.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_276 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_276 instance = new BenchmarkDotNet.Autogenerated.Runnable_276(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_276()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanCopyTo;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_276.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_276.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanCopyTo();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_277 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_277 instance = new BenchmarkDotNet.Autogenerated.Runnable_277(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_277()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithNativeCall;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_277.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_277.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithNativeCall();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_278 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_278 instance = new BenchmarkDotNet.Autogenerated.Runnable_278(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_278()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandleLongLived;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_278.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_278.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandleLongLived();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_279 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_279 instance = new BenchmarkDotNet.Autogenerated.Runnable_279(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_279()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedKeyword;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_279.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_279.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedKeyword();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_280 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_280 instance = new BenchmarkDotNet.Autogenerated.Runnable_280(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_280()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandlePinned;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_280.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_280.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandlePinned();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_281 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_281 instance = new BenchmarkDotNet.Autogenerated.Runnable_281(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_281()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanWithMemoryMarshal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_281.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_281.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanWithMemoryMarshal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_282 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_282 instance = new BenchmarkDotNet.Autogenerated.Runnable_282(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_282()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_282.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_282.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_283 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_283 instance = new BenchmarkDotNet.Autogenerated.Runnable_283(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_283()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanCopyTo;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_283.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_283.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanCopyTo();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_284 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_284 instance = new BenchmarkDotNet.Autogenerated.Runnable_284(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_284()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithNativeCall;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_284.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_284.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithNativeCall();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_285 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_285 instance = new BenchmarkDotNet.Autogenerated.Runnable_285(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 65536;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_285()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandleLongLived;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_285.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_285.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandleLongLived();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_286 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_286 instance = new BenchmarkDotNet.Autogenerated.Runnable_286(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_286()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedKeyword;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_286.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_286.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedKeyword();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_287 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_287 instance = new BenchmarkDotNet.Autogenerated.Runnable_287(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_287()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandlePinned;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_287.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_287.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandlePinned();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_288 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_288 instance = new BenchmarkDotNet.Autogenerated.Runnable_288(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_288()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanWithMemoryMarshal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_288.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_288.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanWithMemoryMarshal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_289 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_289 instance = new BenchmarkDotNet.Autogenerated.Runnable_289(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_289()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_289.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_289.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_290 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_290 instance = new BenchmarkDotNet.Autogenerated.Runnable_290(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_290()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanCopyTo;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_290.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_290.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanCopyTo();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_291 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_291 instance = new BenchmarkDotNet.Autogenerated.Runnable_291(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_291()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithNativeCall;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_291.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_291.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithNativeCall();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_292 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_292 instance = new BenchmarkDotNet.Autogenerated.Runnable_292(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_292()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandleLongLived;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_292.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_292.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandleLongLived();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_293 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_293 instance = new BenchmarkDotNet.Autogenerated.Runnable_293(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_293()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedKeyword;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_293.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_293.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedKeyword();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_294 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_294 instance = new BenchmarkDotNet.Autogenerated.Runnable_294(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_294()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandlePinned;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_294.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_294.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandlePinned();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_295 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_295 instance = new BenchmarkDotNet.Autogenerated.Runnable_295(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_295()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanWithMemoryMarshal;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_295.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_295.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanWithMemoryMarshal();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_296 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_296 instance = new BenchmarkDotNet.Autogenerated.Runnable_296(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_296()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithMemoryCopy;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_296.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_296.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithMemoryCopy();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_297 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_297 instance = new BenchmarkDotNet.Autogenerated.Runnable_297(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_297()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SpanCopyTo;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_297.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_297.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SpanCopyTo();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_298 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_298 instance = new BenchmarkDotNet.Autogenerated.Runnable_298(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_298()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = FixedWithNativeCall;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_298.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_298.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                FixedWithNativeCall();
            }
        }
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_299 : global::NativeMemory.Benchmarks.Benchmarks.PinningBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_299 instance = new BenchmarkDotNet.Autogenerated.Runnable_299(); // do NOT change name "instance" (used in SmartParamameter)
            instance.Size = 1048576;instance.Iterations = 10000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            BenchmarkDotNet.Jobs.GcMode.ConcurrentCharacteristic[job] = true;
                BenchmarkDotNet.Jobs.GcMode.ForceCharacteristic[job] = false;
                BenchmarkDotNet.Jobs.GcMode.ServerCharacteristic[job] = true;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_299()
        {
            globalSetupAction = Setup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GCHandleLongLived;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_299.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_299.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }


        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GCHandleLongLived();
            }
        }
    }
}
