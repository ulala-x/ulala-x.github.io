---
author: Ulala-X
pubDatetime: 2025-12-23T00:00:00+09:00
title: C# vs Java ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬ ì²˜ë¦¬ ë°©ì‹ì˜ ê²°ì •ì  ì°¨ì´ - Pin vs Copy
slug: csharp-java-native-memory-ko
featured: true
draft: false
lang: ko
lang_ref: csharp-java-native-memory
tags:
  - csharp
  - java
  - native-memory
  - performance
  - benchmark
description: C#ì˜ Zero-copy Pinningê³¼ Javaì˜ í•„ìˆ˜ Copy ë©”ì»¤ë‹ˆì¦˜ ë¹„êµ ë¶„ì„
---

# C# vs Java ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬ ì²˜ë¦¬ ë°©ì‹ì˜ ê²°ì •ì  ì°¨ì´ - Pin vs Copy

> C#ì˜ Zero-copy Pinningê³¼ Javaì˜ í•„ìˆ˜ Copy ë©”ì»¤ë‹ˆì¦˜ ë¹„êµ ë¶„ì„

**2025ë…„ 12ì›” 23ì¼**

---

## ì™œ ì´ ì°¨ì´ê°€ ì¤‘ìš”í•œê°€

ë„¤ì´í‹°ë¸Œ ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ í†µì‹ í•˜ê±°ë‚˜ ê³ ì„±ëŠ¥ I/Oë¥¼ ë‹¤ë£° ë•Œ, ê´€ë¦¬ ë©”ëª¨ë¦¬(Managed Memory)ì™€ ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬(Native Memory) ê°„ì˜ ë°ì´í„° ì „ë‹¬ì€ í”¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì´ë•Œ C#ê³¼ Javaê°€ ê·¼ë³¸ì ìœ¼ë¡œ ë‹¤ë¥¸ ë©”ì»¤ë‹ˆì¦˜ì„ ì‚¬ìš©í•©ë‹ˆë‹¤:

- **C#**: `fixed` í‚¤ì›Œë“œë¡œ ê´€ë¦¬ ë°°ì—´ì„ ë„¤ì´í‹°ë¸Œì— Zero-copyë¡œ ì „ë‹¬ ê°€ëŠ¥
- **Java**: Pin ê¸°ëŠ¥ì´ ì—†ì–´ì„œ Heap â†’ Native ë³µì‚¬ í•„ìˆ˜

ì´ ì°¨ì´ëŠ” ëŒ€ìš©ëŸ‰ ë°ì´í„°ë¥¼ ë¹ˆë²ˆí•˜ê²Œ ì²˜ë¦¬í•  ë•Œ ì„±ëŠ¥ ì°¨ì´ë¡œ ì§ê²°ë©ë‹ˆë‹¤. ì´ ê¸€ì—ì„œëŠ” ë‘ ì–¸ì–´ì˜ ë©”ëª¨ë¦¬ ì²˜ë¦¬ ë°©ì‹ì„ ë²¤ì¹˜ë§ˆí¬ ë°ì´í„°ë¥¼ í†µí•´ êµ¬ì²´ì ìœ¼ë¡œ ë¹„êµí•©ë‹ˆë‹¤.

---

## Chapter 1: C# ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬ ì²˜ë¦¬

C#ì€ ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬ë¥¼ ë‹¤ë£¨ëŠ” ì—¬ëŸ¬ ë°©ë²•ì„ ì œê³µí•©ë‹ˆë‹¤. ê°ê°ì˜ ì„±ëŠ¥ íŠ¹ì„±ì„ ë²¤ì¹˜ë§ˆí¬ë¥¼ í†µí•´ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

### 1.1 ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬ í• ë‹¹ ë°©ì‹

**í…ŒìŠ¤íŠ¸ í™˜ê²½**:
- CPU: Intel Core Ultra 7 265K (20 cores)
- OS: Ubuntu 24.04.3 LTS
- Runtime: .NET 8.0.22
- BenchmarkDotNet v0.14.0

> **ì‹œê°„ ë‹¨ìœ„ ì•ˆë‚´**
> - **Î¼s (ë§ˆì´í¬ë¡œì´ˆ)**: 1Î¼s = 0.000001ì´ˆ = 1/1,000,000ì´ˆ
> - **ns (ë‚˜ë…¸ì´ˆ)**: 1ns = 0.000000001ì´ˆ = 1/1,000,000,000ì´ˆ
> - ì°¸ê³ : 1ms(ë°€ë¦¬ì´ˆ) = 1,000Î¼s = 1,000,000ns

| ë°©ì‹ | 64B | 1KB | 64KB | 1MB |
|-----|-----|-----|------|-----|
| StackAlloc | 11.7 Î¼s | 12.1 Î¼s | 30.0 Î¼s | 106.1 Î¼s |
| NativeMemory.Alloc | 63.6 Î¼s | 61.5 Î¼s | 61.2 Î¼s | 61.4 Î¼s |
| Marshal.AllocHGlobal | 74.3 Î¼s | 72.6 Î¼s | 82.8 Î¼s | 86.3 Î¼s |

**í•µì‹¬ í†µì°°**:

1. **StackAlloc**ì´ 64Bì—ì„œ 11.7 Î¼së¡œ ê°€ì¥ ë¹ ë¥´ì§€ë§Œ, í¬ê¸°ê°€ ì»¤ì§ˆìˆ˜ë¡ ì„±ëŠ¥ì´ ì €í•˜ë©ë‹ˆë‹¤ (1MBì—ì„œ 106.1 Î¼s).
2. **NativeMemory.Alloc**ì€ í¬ê¸°ì™€ ë¬´ê´€í•˜ê²Œ ì¼ì •í•œ ì„±ëŠ¥ (ì•½ 61-63 Î¼s)ì„ ë³´ì…ë‹ˆë‹¤. ì´ëŠ” í™ í• ë‹¹ ë©”ì»¤ë‹ˆì¦˜ì˜ ì•ˆì •ì„±ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.
3. **Marshal.AllocHGlobal**ì€ ë ˆê±°ì‹œ APIë¡œ ëª¨ë“  í¬ê¸°ì—ì„œ ê°€ì¥ ëŠë¦½ë‹ˆë‹¤.

**ì‹¤ë¬´ ê°€ì´ë“œ**: ìŠ¤íƒì— ì•ˆì „í•˜ê²Œ í• ë‹¹ ê°€ëŠ¥í•œ ì‘ì€ í¬ê¸°(< 1KB)ëŠ” StackAlloc, ê·¸ ì™¸ëŠ” NativeMemory.Allocì„ ê¶Œì¥í•©ë‹ˆë‹¤.

**ê° í• ë‹¹ ë°©ì‹ì˜ êµ¬ì²´ì ì¸ ì‚¬ìš© ì˜ˆì œ**:

```csharp
// 1. StackAlloc - ìŠ¤íƒ ë©”ëª¨ë¦¬ì— í• ë‹¹
unsafe
{
    byte* buffer = stackalloc byte[1024];
    // í•¨ìˆ˜ ì¢…ë£Œ ì‹œ ìë™ í•´ì œ
}

// 2. NativeMemory.Alloc - ë„¤ì´í‹°ë¸Œ í™ì— í• ë‹¹ (.NET 6+)
unsafe
{
    byte* buffer = (byte*)NativeMemory.Alloc(1024);
    try {
        // ì‚¬ìš©
    } finally {
        NativeMemory.Free(buffer);
    }
}

// 3. Marshal.AllocHGlobal - ë„¤ì´í‹°ë¸Œ í™ì— í• ë‹¹ (ë ˆê±°ì‹œ)
IntPtr buffer = Marshal.AllocHGlobal(1024);
try {
    // ì‚¬ìš©
} finally {
    Marshal.FreeHGlobal(buffer);
}
```

**ë©”ëª¨ë¦¬ í• ë‹¹ ë°©ì‹ íŠ¹ì§• ë¹„êµ**:

| ë°©ì‹ | í• ë‹¹ ìœ„ì¹˜ | GC ê´€ë¦¬ | í•´ì œ ë°©ì‹ | íŠ¹ì§• |
|-----|---------|--------|---------|-----|
| `stackalloc` | ìŠ¤íƒ | âŒ | ìë™ (ìŠ¤ì½”í”„ ì¢…ë£Œ) | ê°€ì¥ ë¹ ë¦„, í¬ê¸° ì œí•œ (ìµœëŒ€ ~1MB, ê¶Œì¥ < 1KB) |
| `NativeMemory.Alloc` | ë„¤ì´í‹°ë¸Œ í™ | âŒ | ìˆ˜ë™ (`Free`) | ì¼ì •í•œ ì„±ëŠ¥, í˜„ëŒ€ì  API |
| `Marshal.AllocHGlobal` | ë„¤ì´í‹°ë¸Œ í™ | âŒ | ìˆ˜ë™ (`FreeHGlobal`) | ë ˆê±°ì‹œ, P/Invoke í˜¸í™˜ |
| `new byte[]` | Managed Heap | âœ… | GC | ê°€ì¥ ì•ˆì „, GC ë¶€í•˜ |

**C# í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬ êµ¬ì¡°**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Stack         â”‚  Managed Heap   â”‚     Native Heap         â”‚
â”‚   (ìŠ¤íƒ)         â”‚  (ê´€ë¦¬ í™)       â”‚     (ë„¤ì´í‹°ë¸Œ í™)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ stackalloc    â”‚ â€¢ new byte[]    â”‚ â€¢ NativeMemory.Alloc    â”‚
â”‚ â€¢ í•¨ìˆ˜ ë¡œì»¬ ë³€ìˆ˜  â”‚ â€¢ GCê°€ ê´€ë¦¬      â”‚ â€¢ Marshal.AllocHGlobal  â”‚
â”‚ â€¢ ìë™ í•´ì œ      â”‚ â€¢ ìë™ í•´ì œ      â”‚ â€¢ ìˆ˜ë™ í•´ì œ í•„ìš”         â”‚
â”‚ â€¢ ~1MB ì œí•œ     â”‚ â€¢ í¬ê¸° ì œí•œ ì—†ìŒ  â”‚ â€¢ í¬ê¸° ì œí•œ ì—†ìŒ         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 C#ì˜ í•µì‹¬ ê°•ì : Zero-copy Pinning

C#ì˜ ê°€ì¥ ê°•ë ¥í•œ ê¸°ëŠ¥ì€ `fixed` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•œ Zero-copy ì „ë‹¬ì…ë‹ˆë‹¤.

```csharp
byte[] managedArray = new byte[1024];

// fixedë¡œ GCê°€ ë©”ëª¨ë¦¬ë¥¼ ì´ë™í•˜ì§€ ëª»í•˜ë„ë¡ ê³ ì •
unsafe
{
    fixed (byte* ptr = managedArray)
    {
        // ë³µì‚¬ ì—†ì´ ë„¤ì´í‹°ë¸Œ ì½”ë“œì— í¬ì¸í„° ì „ë‹¬
        NativeLibrary.ProcessData(ptr, managedArray.Length);
    }
}
// fixed ë¸”ë¡ì„ ë²—ì–´ë‚˜ë©´ ìë™ìœ¼ë¡œ unpin
```

**Pinning ë²¤ì¹˜ë§ˆí¬** (10,000íšŒ ë°˜ë³µ):

| ë°©ì‹ | 64B | 1KB | 64KB | 1MB |
|-----|-----|-----|------|-----|
| Fixed (pin only) | 5.8 Î¼s | 5.8 Î¼s | 26.4 Î¼s | 28.9 Î¼s |
| GCHandle.Pinned | 245.4 Î¼s | 245.5 Î¼s | 260.5 Î¼s | 259.8 Î¼s |
| MemoryMarshal (Span) | 4.2 Î¼s | 4.3 Î¼s | 4.5 Î¼s | 4.6 Î¼s |

**í•µì‹¬ í†µì°°**:

1. **MemoryMarshal.GetReference**ì™€ Spanì„ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ì´ ëª¨ë“  í¬ê¸°ì—ì„œ ì•½ 4.2-4.6 Î¼së¡œ ê°€ì¥ ë¹ ë¦…ë‹ˆë‹¤.
2. **fixed** í‚¤ì›Œë“œëŠ” 64B~1KBì—ì„œ 5.8 Î¼së¡œ ì¤€ìˆ˜í•œ ì„±ëŠ¥ì„ ë³´ì…ë‹ˆë‹¤.
3. **GCHandle.Pinned**ëŠ” 245 Î¼së¡œ í˜„ì €íˆ ëŠë¦½ë‹ˆë‹¤. ëª…ì‹œì  í• ë‹¹/í•´ì œ ì˜¤ë²„í—¤ë“œê°€ í½ë‹ˆë‹¤.

### 1.3 Managed â†’ Native ë°ì´í„° ì „ë‹¬ ì„±ëŠ¥

ê´€ë¦¬ ë°°ì—´ì—ì„œ ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬ë¡œ ë°ì´í„°ë¥¼ ì „ë‹¬í•˜ëŠ” ë°©ì‹ì„ ë¹„êµí–ˆìŠµë‹ˆë‹¤.

**ë²¤ì¹˜ë§ˆí¬ ê²°ê³¼** (10,000íšŒ ë°˜ë³µ):

| ë°©ì‹ | 64B | 1KB | 64KB | 1MB |
|-----|-----|-----|------|-----|
| Marshal.Copy | 11.2 Î¼s | 13.8 Î¼s | 106.1 Î¼s | 1,330 Î¼s |
| Buffer.MemoryCopy (fixed) | 12.7 Î¼s | 16.1 Î¼s | 176.1 Î¼s | 2,146 Î¼s |
| Span.CopyTo (native) | 11.2 Î¼s | 15.8 Î¼s | 166.4 Î¼s | 2,104 Î¼s |

**í•µì‹¬ í†µì°°**:

1. **ì‘ì€ í¬ê¸°(64B)ì—ì„œëŠ”** ëª¨ë“  ë°©ë²•ì´ ë¹„ìŠ·í•©ë‹ˆë‹¤ (ì•½ 11-13 Î¼s).
2. **1MB ë°ì´í„°ì—ì„œëŠ”** Marshal.Copyê°€ 1,330 Î¼së¡œ ê°€ì¥ ë¹ ë¥´ê³ , Buffer.MemoryCopyëŠ” 2,146 Î¼së¡œ 1.6ë°° ëŠë¦½ë‹ˆë‹¤.
3. **ë³µì‚¬ê°€ í•„ìš”í•˜ë‹¤ë©´** Marshal.Copyê°€ ê°€ì¥ ë¹ ë¦…ë‹ˆë‹¤. ë‹¨, ì½ê¸° ì „ìš© ì‘ì—…ì´ë¼ë©´ ì„¹ì…˜ 1.2ì²˜ëŸ¼ fixedë¡œ piní•˜ì—¬ ë³µì‚¬ ì—†ì´ ì „ë‹¬í•˜ëŠ” ê²ƒì´ ìµœì„ ì…ë‹ˆë‹¤.

**ê° ë³µì‚¬ ë°©ì‹ì˜ êµ¬ì²´ì ì¸ ì‚¬ìš©ë²•**:

```csharp
byte[] managedArray = new byte[1024];
IntPtr nativePtr = Marshal.AllocHGlobal(1024);

// 1. Marshal.Copy - Managed â†’ Native ë³µì‚¬
Marshal.Copy(managedArray, 0, nativePtr, 1024);

// 2. Buffer.MemoryCopy - fixedë¡œ pin í›„ ë³µì‚¬
unsafe
{
    fixed (byte* src = managedArray)
    {
        Buffer.MemoryCopy(src, (void*)nativePtr, 1024, 1024);
    }
}

// 3. Span.CopyTo - Span ê¸°ë°˜ ë³µì‚¬
unsafe
{
    Span<byte> nativeSpan = new Span<byte>((void*)nativePtr, 1024);
    managedArray.AsSpan().CopyTo(nativeSpan);
}
```

**ë³µì‚¬ ë°©ì‹ë³„ ë‚´ë¶€ ë™ì‘ ë¹„êµ**:

| ë°©ì‹ | ë‚´ë¶€ ë™ì‘ | Pin í•„ìš” | ì¥ì  | ë‹¨ì  |
|-----|---------|---------|-----|-----|
| `Marshal.Copy` | ë‚´ë¶€ì ìœ¼ë¡œ pin + memcpy | ìë™ | ê°€ì¥ ë¹ ë¦„, ê°„ë‹¨, unsafe ë¶ˆí•„ìš” | IntPtr ì‚¬ìš© í•„ìš” |
| `Buffer.MemoryCopy` | memcpy ì§ì ‘ í˜¸ì¶œ | ìˆ˜ë™ (fixed) | ìœ ì—°í•¨, í¬ì¸í„° ì§ì ‘ ì œì–´ | unsafe ë¸”ë¡ í•„ìš” |
| `Span.CopyTo` | ë‚´ë¶€ì ìœ¼ë¡œ memmove | ìˆ˜ë™ (fixed) | í˜„ëŒ€ì  API, íƒ€ì… ì•ˆì „ | ì•½ê°„ ëŠë¦¼ |

**ë³µì‚¬ ë°©ì‹ê³¼ Zero-copy ë°©ì‹ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš© íŒ¨í„´ ë¹„êµ**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [ë³µì‚¬ ë°©ì‹] Marshal.Copy / Buffer.MemoryCopy                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   Managed Heap          memcpy           Native Heap        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ byte[]   â”‚      ë°ì´í„° ë³µì‚¬          â”‚ IntPtr   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                             â”‚
â”‚   â†’ ë©”ëª¨ë¦¬ 2ë°° ì‚¬ìš©, ë³µì‚¬ ì‹œê°„ ì†Œìš”                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [Zero-copy] fixed í‚¤ì›Œë“œ                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   Managed Heap                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                               â”‚
â”‚  â”‚ byte[]   â”‚ â†â”€â”€ fixedë¡œ pin (GCê°€ ì´ë™ ëª»í•¨)               â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                                               â”‚
â”‚       â”‚                                                     â”‚
â”‚       â””â”€â”€â†’ í¬ì¸í„°ë¥¼ ë„¤ì´í‹°ë¸Œ ì½”ë“œì— ì§ì ‘ ì „ë‹¬                  â”‚
â”‚                                                             â”‚
â”‚   â†’ ë©”ëª¨ë¦¬ 1ë°°ë§Œ ì‚¬ìš©, ë³µì‚¬ ì‹œê°„ ì œë¡œ                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ì‹¤ë¬´ ì ìš©**:
```csharp
// ì½ê¸° ì „ìš© ì‘ì—…: Zero-copy Pinning
unsafe
{
    fixed (byte* ptr = managedArray)
    {
        NativeLib.Read(ptr, length); // ë³µì‚¬ ì—†ìŒ
    }
}

// ì“°ê¸° ì‘ì—…: ë³µì‚¬ í•„ìš”
IntPtr nativePtr = Marshal.AllocHGlobal(size);
Marshal.Copy(managedArray, 0, nativePtr, size);
NativeLib.Write(nativePtr, size);
Marshal.FreeHGlobal(nativePtr);
```

---

## Chapter 2: Java ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬ ì²˜ë¦¬

JavaëŠ” JDK 14ë¶€í„° Foreign Memory API (í˜„ì¬ Foreign Function & Memory API)ë¥¼ í†µí•´ ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬ ê´€ë¦¬ë¥¼ ê°œì„ í–ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ í•µì‹¬ì ì¸ ì œì•½ì´ ìˆìŠµë‹ˆë‹¤: **Heap ë°°ì—´ì„ piní•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤**.

### 2.1 Arena ê¸°ë°˜ ë©”ëª¨ë¦¬ í• ë‹¹

**í…ŒìŠ¤íŠ¸ í™˜ê²½**:
- Java: OpenJDK 22.0.2
- JMH 1.37
- OS: Ubuntu 24.04.3 LTS
- CPU: Intel Core Ultra 7 265K

| Arena íƒ€ì… | 64B | 1KB | 64KB | 1MB |
|-----------|-----|-----|------|-----|
| Confined (thread-local) | 42 ns | 47 ns | 887 ns | 13,400 ns |
| Shared (thread-safe) | 31,628 ns | 32,578 ns | 34,144 ns | 53,592 ns |
| Global (ì˜êµ¬) | 88 ns | 630 ns | 35,520 ns | 559,392 ns |
| Auto (ìë™ ê´€ë¦¬) | 482 ns | 818 ns | 37,572 ns | 635,644 ns |

**í•µì‹¬ í†µì°°**:

1. **Confined Arena**ê°€ ëª¨ë“  í¬ê¸°ì—ì„œ ê°€ì¥ ë¹ ë¦…ë‹ˆë‹¤. ë‹¨ì¼ ìŠ¤ë ˆë“œ ì „ìš©ì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
2. **Shared Arena**ëŠ” ì‘ì€ í¬ê¸°ì—ì„œ ì•½ 31 Î¼së¡œ ë§¤ìš° ëŠë¦½ë‹ˆë‹¤. ë™ê¸°í™” ì˜¤ë²„í—¤ë“œ ë•Œë¬¸ì…ë‹ˆë‹¤.
3. **í° í¬ê¸°(1MB)**ì—ì„œëŠ” ëª¨ë“  íƒ€ì…ì´ ë¹„ìŠ·í•œ ì„±ëŠ¥ì„ ë³´ì…ë‹ˆë‹¤ (ì•½ 13-635 Î¼s).

**C#ê³¼ì˜ ë¹„êµ**:
- C# NativeMemory.Alloc: 61-63 Î¼s (í¬ê¸° ë¬´ê´€)
- Java Confined Arena: 42 ns ~ 13.4 Î¼s (í¬ê¸° ì˜ì¡´ì )

ì‘ì€ í¬ê¸°ì—ì„œëŠ” Javaê°€ ë” ë¹ ë¥´ì§€ë§Œ, JavaëŠ” ìŠ¤ë ˆë“œ ì•ˆì „ì„±ì„ ìœ„í•´ Shared Arenaë¥¼ ì‚¬ìš©í•˜ë©´ ì„±ëŠ¥ì´ ê¸‰ê²©íˆ ë–¨ì–´ì§‘ë‹ˆë‹¤.

**ê° Arena íƒ€ì…ì˜ ì‚¬ìš© ì˜ˆì œ**:

```java
// 1. Confined Arena - ë‹¨ì¼ ìŠ¤ë ˆë“œ ì „ìš©, ê°€ì¥ ë¹ ë¦„
try (Arena arena = Arena.ofConfined()) {
    MemorySegment segment = arena.allocate(1024);
    // ì´ ìŠ¤ë ˆë“œì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥
} // ìë™ í•´ì œ

// 2. Shared Arena - ë©€í‹°ìŠ¤ë ˆë“œ ì•ˆì „
try (Arena arena = Arena.ofShared()) {
    MemorySegment segment = arena.allocate(1024);
    // ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ê³µìœ  ê°€ëŠ¥
} // ìë™ í•´ì œ

// 3. Global Arena - ì˜êµ¬ í• ë‹¹
MemorySegment segment = Arena.global().allocate(1024);
// í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ì‹œê¹Œì§€ ìœ ì§€, í•´ì œ ë¶ˆê°€

// 4. Auto Arena - GC ê¸°ë°˜ ìë™ ê´€ë¦¬
Arena arena = Arena.ofAuto();
MemorySegment segment = arena.allocate(1024);
// close() ë¶ˆí•„ìš”, GCê°€ ê´€ë¦¬
```

**Arena íƒ€ì…ë³„ íŠ¹ì§• ë¹„êµ**:

| Arena íƒ€ì… | ìŠ¤ë ˆë“œ ì•ˆì „ | í•´ì œ ë°©ì‹ | ì„±ëŠ¥ | ì‚¬ìš© ì‚¬ë¡€ |
|-----------|-----------|---------|-----|---------|
| `Confined` | âŒ ë‹¨ì¼ ìŠ¤ë ˆë“œ | try-with-resources | ğŸš€ ê°€ì¥ ë¹ ë¦„ | ë¡œì»¬ ì‘ì—… |
| `Shared` | âœ… ë©€í‹°ìŠ¤ë ˆë“œ | try-with-resources | ğŸ¢ ë™ê¸°í™” ì˜¤ë²„í—¤ë“œ | ìŠ¤ë ˆë“œ ê°„ ê³µìœ  |
| `Global` | âœ… ë©€í‹°ìŠ¤ë ˆë“œ | í•´ì œ ë¶ˆê°€ | âš¡ ë¹ ë¦„ | ìƒìˆ˜, ì „ì—­ ë°ì´í„° |
| `Auto` | âœ… ë©€í‹°ìŠ¤ë ˆë“œ | GC ìë™ | ğŸ”„ GC ì˜ì¡´ | ìˆ˜ëª… ë¶ˆëª…í™• ì‹œ |

**Java í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬ êµ¬ì¡°**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      JVM í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Java Heap       â”‚           Native Memory               â”‚
â”‚     (ìë°” í™)        â”‚          (ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ byte[] ë°°ì—´        â”‚ â€¢ MemorySegment (Arena)               â”‚
â”‚ â€¢ ê°ì²´ ì¸ìŠ¤í„´ìŠ¤       â”‚ â€¢ DirectByteBuffer ë‚´ë¶€ ë²„í¼           â”‚
â”‚ â€¢ GCê°€ ê´€ë¦¬          â”‚ â€¢ JNI ë„¤ì´í‹°ë¸Œ í• ë‹¹                    â”‚
â”‚                     â”‚ â€¢ Arena.close()ë¡œ í•´ì œ                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  âš ï¸ JavaëŠ” Heap ë°°ì—´ì„ Piní•  ìˆ˜ ì—†ìŒ â†’ Native ì „ë‹¬ ì‹œ ë³µì‚¬ í•„ìˆ˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Javaì˜ ê·¼ë³¸ì  ì œì•½: Heap â†’ Native ë³µì‚¬ í•„ìˆ˜

JavaëŠ” Heap ë°°ì—´ì„ piní•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ **ëª¨ë“  Heap ë°ì´í„°ë¥¼ ë„¤ì´í‹°ë¸Œë¡œ ì „ë‹¬í•˜ë ¤ë©´ ë³µì‚¬ê°€ í•„ìˆ˜**ì…ë‹ˆë‹¤.

**Heap â†’ Native ë³µì‚¬ ë²¤ì¹˜ë§ˆí¬**:

| ë°©ì‹ | 64B | 1KB | 64KB | 1MB |
|-----|-----|-----|------|-----|
| Heap â†’ MemorySegment Copy | 44 ns | 52 ns | 1,825 ns | 39,434 ns |
| Heap â†’ DirectBuffer Copy | 373 ns | 743 ns | 36,175 ns | 553,142 ns |
| Heap â†’ Native (ì¬ì‚¬ìš©) | 2.5 ns | 8.4 ns | 1,390 ns | 25,074 ns |

**í•µì‹¬ í†µì°°**:

1. **ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ë²„í¼**ë¥¼ ì‚¬ìš©í•˜ë©´ ë³µì‚¬ ì˜¤ë²„í—¤ë“œë¥¼ í¬ê²Œ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤ (1MBì—ì„œ 25 Î¼s).
2. **DirectBuffer**ëŠ” ë§¤ë²ˆ í• ë‹¹í•˜ë©´ ë§¤ìš° ëŠë¦½ë‹ˆë‹¤ (1MBì—ì„œ 553 Î¼s).
3. **MemorySegment**ê°€ DirectBufferë³´ë‹¤ ì¼ë°˜ì ìœ¼ë¡œ ë¹ ë¦…ë‹ˆë‹¤.

**C#ê³¼ì˜ ê²°ì •ì  ì°¨ì´**:

```java
// Java: ë³µì‚¬ í•„ìˆ˜
byte[] heapArray = new byte[1024];
try (Arena arena = Arena.ofConfined()) {
    MemorySegment segment = arena.allocate(1024);
    MemorySegment.copy(heapArray, 0, segment, ValueLayout.JAVA_BYTE, 0, 1024); // ë³µì‚¬ ë°œìƒ
    nativeProcess(segment);
}
```

```csharp
// C#: Zero-copy ê°€ëŠ¥
byte[] managedArray = new byte[1024];
unsafe {
    fixed (byte* ptr = managedArray) {
        NativeProcess(ptr); // ë³µì‚¬ ì—†ìŒ
    }
}
```

### 2.3 DirectByteBuffer vs MemorySegment

**í• ë‹¹ ì„±ëŠ¥**:

| ë°©ì‹ | 64B | 1KB | 64KB | 1MB |
|-----|-----|-----|------|-----|
| DirectByteBuffer.allocate | 367 ns | 708 ns | 33,489 ns | 578,204 ns |
| MemorySegment.allocate | 43 ns | 50 ns | 930 ns | 13,480 ns |

**MemorySegmentê°€ DirectByteBufferë³´ë‹¤ 42ë°° ë¹ ë¦…ë‹ˆë‹¤** (1MB ê¸°ì¤€).

**ì‹¤ë¬´ ê°€ì´ë“œ**:
- ë ˆê±°ì‹œ ì½”ë“œê°€ ì•„ë‹ˆë¼ë©´ DirectByteBuffer ëŒ€ì‹  MemorySegment ì‚¬ìš© ê¶Œì¥
- ë¹ˆë²ˆí•œ í• ë‹¹ì´ í•„ìš”í•˜ë©´ Arenaë¥¼ ì¬ì‚¬ìš©í•˜ì—¬ í• ë‹¹ ì˜¤ë²„í—¤ë“œ ìµœì†Œí™”

---

## Chapter 3: Pin vs Copy - í•µì‹¬ ì°¨ì´ì 

### 3.1 ì•„í‚¤í…ì²˜ ìˆ˜ì¤€ì˜ ì°¨ì´

| íŠ¹ì„± | C# | Java |
|-----|-----|------|
| **Pinning ì§€ì›** | âœ… `fixed`, `GCHandle` | âŒ ë¶ˆê°€ëŠ¥ |
| **Zero-copy ì „ë‹¬** | âœ… Managed â†’ Native ì§ì ‘ ì „ë‹¬ | âŒ ë³µì‚¬ í•„ìˆ˜ |
| **GC ì˜í–¥** | Pin ì¤‘ì—ëŠ” ë©”ëª¨ë¦¬ ì´ë™ ë¶ˆê°€ | GCì™€ ë…ë¦½ì  (ë³µì‚¬í•˜ë¯€ë¡œ) |
| **ì„±ëŠ¥ íŠ¹ì„±** | ë³µì‚¬ ë¹„ìš© ì œë¡œ | í¬ê¸°ì— ë¹„ë¡€í•œ ë³µì‚¬ ë¹„ìš© |
| **ì•ˆì „ì„±** | Unsafe ë¸”ë¡ í•„ìš” | íƒ€ì… ì•ˆì „ |

### 3.2 ì„±ëŠ¥ ì„íŒ©íŠ¸ ë¹„êµ

**1MB ë°ì´í„°ë¥¼ ë„¤ì´í‹°ë¸Œë¡œ ì „ë‹¬í•˜ëŠ” ë¹„ìš©**:

| ì–¸ì–´ | ë°©ì‹ | ì‹œê°„ | ë¹„ê³  |
|-----|-----|------|------|
| C# | Fixed (Zero-copy) | ~29 Î¼s | Pinë§Œ |
| C# | Marshal.Copy | 1,330 Î¼s | ë³µì‚¬ í¬í•¨ |
| Java | Heap â†’ MemorySegment | 39,434 ns (39.4 Î¼s) | ë³µì‚¬ í•„ìˆ˜ |
| Java | ì¬ì‚¬ìš© ë²„í¼ | 25,074 ns (25.1 Î¼s) | ìµœì í™”ëœ ë³µì‚¬ |

**í•µì‹¬ í†µì°°**:

1. **C# Zero-copy**: 29 Î¼s (ê°€ì¥ ë¹ ë¦„)
2. **Java ìµœì í™”ëœ ë³µì‚¬**: 25.1 Î¼s (C#ê³¼ ë¹„ìŠ·)
3. **C# Marshal.Copy**: 1,330 Î¼s (ê°€ì¥ ëŠë¦¼)

í¥ë¯¸ë¡­ê²Œë„, Javaê°€ ì¬ì‚¬ìš© ë²„í¼ë¡œ ë³µì‚¬í•˜ëŠ” ê²ƒì´ C#ì˜ Marshal.Copyë³´ë‹¤ 53ë°° ë¹ ë¦…ë‹ˆë‹¤. í•˜ì§€ë§Œ C#ì€ fixedë¥¼ ì‚¬ìš©í•˜ë©´ ë³µì‚¬ ìì²´ë¥¼ í”¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 3.3 ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ ì‹œë‚˜ë¦¬ì˜¤

**ì‹œë‚˜ë¦¬ì˜¤**: 1MB ë°ì´í„°ë¥¼ 1,000ë²ˆ ë„¤ì´í‹°ë¸Œë¡œ ì „ë‹¬

| ì–¸ì–´ | ë°©ì‹ | ì´ ì‹œê°„ (ì˜ˆì¸¡) |
|-----|-----|---------------|
| C# | Fixed (Zero-copy) | ~29 ms |
| Java | ì¬ì‚¬ìš© ë²„í¼ ë³µì‚¬ | ~25.1 ms |
| Java | ë§¤ë²ˆ í• ë‹¹/ë³µì‚¬ | ~39.4 ms |
| C# | Marshal.Copy | ~1,330 ms |

**ì‹¤ë¬´ ì˜ë¯¸**:
- ë„¤ì´í‹°ë¸Œ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì½ê¸° ì „ìš©ìœ¼ë¡œ ë°ì´í„°ë¥¼ ì‚¬ìš©í•œë‹¤ë©´, C#ì˜ fixedê°€ ìµœì„ ì…ë‹ˆë‹¤.
- JavaëŠ” ë²„í¼ë¥¼ ì¬ì‚¬ìš©í•˜ëŠ” ê²ƒì´ í•„ìˆ˜ì…ë‹ˆë‹¤. ë§¤ë²ˆ í• ë‹¹í•˜ë©´ 57% ë” ëŠë¦½ë‹ˆë‹¤.

---

## Chapter 4: ì‹¤ë¬´ ì ìš© ê°€ì´ë“œ

### 4.1 C# ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬ ì‚¬ìš© íŒ¨í„´

**íŒ¨í„´ 1: ì½ê¸° ì „ìš© ë°ì´í„°ë¥¼ ë„¤ì´í‹°ë¸Œë¡œ ì „ë‹¬**

```csharp
// Zero-copyë¡œ ë„¤ì´í‹°ë¸Œì— ì „ë‹¬
byte[] imageData = LoadImage();

unsafe
{
    fixed (byte* ptr = imageData)
    {
        ProcessImageNative(ptr, imageData.Length);
    }
}
```

**ì ìš© ì¼€ì´ìŠ¤**:
- ì´ë¯¸ì§€/ë¹„ë””ì˜¤ ì²˜ë¦¬ (OpenCV, FFmpeg ë“±)
- ì•”í˜¸í™” ë¼ì´ë¸ŒëŸ¬ë¦¬ (OpenSSL ë“±)
- ë„¤íŠ¸ì›Œí¬ íŒ¨í‚· ì²˜ë¦¬

**íŒ¨í„´ 2: ì“°ê¸° ê°€ëŠ¥í•œ ë„¤ì´í‹°ë¸Œ ë²„í¼**

```csharp
// NativeMemory.Allocìœ¼ë¡œ ë„¤ì´í‹°ë¸Œ ë²„í¼ í• ë‹¹
unsafe
{
    byte* nativeBuffer = (byte*)NativeMemory.Alloc(1024);

    try
    {
        FillDataNative(nativeBuffer, 1024);

        // ê²°ê³¼ë¥¼ managedë¡œ ë³µì‚¬
        byte[] result = new byte[1024];
        fixed (byte* dest = result)
        {
            Buffer.MemoryCopy(nativeBuffer, dest, 1024, 1024);
        }
    }
    finally
    {
        NativeMemory.Free(nativeBuffer);
    }
}
```

**íŒ¨í„´ 3: ê³ ì„±ëŠ¥ I/O with Span**

```csharp
// Spanìœ¼ë¡œ Zero-copy ì½ê¸°/ì“°ê¸°
Span<byte> buffer = stackalloc byte[512];

int bytesRead = socket.Receive(buffer);

unsafe
{
    fixed (byte* ptr = buffer)
    {
        ProcessData(ptr, bytesRead);
    }
}
```

### 4.2 Java ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬ ì‚¬ìš© íŒ¨í„´

**íŒ¨í„´ 1: Arena ì¬ì‚¬ìš©ìœ¼ë¡œ í• ë‹¹ ìµœì†Œí™”**

```java
// Arenaë¥¼ ë¯¸ë¦¬ ìƒì„±í•˜ì—¬ ì¬ì‚¬ìš©
private final Arena arena = Arena.ofShared();
private final MemorySegment reusableBuffer =
    arena.allocate(1024 * 1024); // 1MB ë²„í¼

public void processData(byte[] heapData) {
    // ì¬ì‚¬ìš© ë²„í¼ì— ë³µì‚¬
    MemorySegment.copy(heapData, 0,
        reusableBuffer, ValueLayout.JAVA_BYTE, 0, heapData.length);

    nativeProcess(reusableBuffer);
}

// ì¢…ë£Œ ì‹œ
public void close() {
    arena.close();
}
```

**íŒ¨í„´ 2: ìŠ¤íŠ¸ë¦¬ë° ë°ì´í„° ì²˜ë¦¬**

```java
// ì²­í¬ ë‹¨ìœ„ë¡œ ì²˜ë¦¬í•˜ì—¬ ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± í™•ë³´
try (Arena arena = Arena.ofConfined()) {
    MemorySegment chunk = arena.allocate(4096);

    while (hasMoreData()) {
        byte[] heapChunk = readChunk();
        MemorySegment.copy(heapChunk, 0, chunk, ValueLayout.JAVA_BYTE, 0, heapChunk.length);
        processChunk(chunk);
    }
}
```

**íŒ¨í„´ 3: DirectByteBuffer ë ˆê±°ì‹œ ì½”ë“œ**

```java
// ë ˆê±°ì‹œ NIO ì½”ë“œì™€ í†µí•©
ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);
directBuffer.put(heapArray);
directBuffer.flip();

// MemorySegmentë¡œ ë˜í•‘ (Zero-copy)
MemorySegment segment = MemorySegment.ofBuffer(directBuffer);
nativeProcess(segment.address());
```

### 4.3 ì–¸ì œ ì–´ë–¤ ì–¸ì–´ë¥¼ ì„ íƒí•  ê²ƒì¸ê°€

**C#ì„ ì„ íƒí•´ì•¼ í•˜ëŠ” ê²½ìš°**:

1. **ëŒ€ìš©ëŸ‰ ë°ì´í„° ì½ê¸° ì „ìš© ì²˜ë¦¬**
   - ì˜ˆ: 100MB ì´ë¯¸ì§€ë¥¼ ë„¤ì´í‹°ë¸Œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ ì²˜ë¦¬
   - ì´ìœ : Zero-copyë¡œ ë³µì‚¬ ë¹„ìš© ì œë¡œ

2. **ë¹ˆë²ˆí•œ Managed â†” Native ì „í™˜**
   - ì˜ˆ: ì´ˆë‹¹ 10,000ë²ˆ ë„¤ì´í‹°ë¸Œ í•¨ìˆ˜ í˜¸ì¶œ
   - ì´ìœ : fixed í‚¤ì›Œë“œë¡œ ì˜¤ë²„í—¤ë“œ ìµœì†Œí™”

3. **ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±ì´ ì¤‘ìš”í•œ ê²½ìš°**
   - ì˜ˆ: IoT ë””ë°”ì´ìŠ¤, ì„ë² ë””ë“œ ì‹œìŠ¤í…œ
   - ì´ìœ : ë³µì‚¬ ì—†ì´ ë©”ëª¨ë¦¬ ì¬ì‚¬ìš© ê°€ëŠ¥

**Javaë¥¼ ì„ íƒí•´ì•¼ í•˜ëŠ” ê²½ìš°**:

1. **ì•ˆì „ì„±ì´ ìµœìš°ì„ ì¸ ê²½ìš°**
   - ì˜ˆ: ê¸ˆìœµ ì‹œìŠ¤í…œ, ì˜ë£Œ ì‹œìŠ¤í…œ
   - ì´ìœ : Unsafe ì—†ì´ íƒ€ì… ì•ˆì „í•œ API

2. **í¬ë¡œìŠ¤ í”Œë«í¼ ì¼ê´€ì„±**
   - ì˜ˆ: Linux/macOS/Windows ë™ì¼ ì½”ë“œ
   - ì´ìœ : JVMì´ í”Œë«í¼ ì°¨ì´ í¡ìˆ˜

3. **ì‘ì€ í¬ê¸° ë°ì´í„° ì²˜ë¦¬**
   - ì˜ˆ: 1KB ë¯¸ë§Œ ë¹ˆë²ˆí•œ ë„¤ì´í‹°ë¸Œ í˜¸ì¶œ
   - ì´ìœ : ë³µì‚¬ ì˜¤ë²„í—¤ë“œê°€ ë¯¸ë¯¸í•¨ (< 100ns)

---

## ê²°ë¡ 

### í•µì‹¬ ìš”ì•½

1. **C#ì˜ ê°•ì : Zero-copy Pinning**
   - `fixed` í‚¤ì›Œë“œë¡œ ê´€ë¦¬ ë°°ì—´ì„ ë„¤ì´í‹°ë¸Œì— ì§ì ‘ ì „ë‹¬
   - ëŒ€ìš©ëŸ‰ ë°ì´í„°ì—ì„œ ë³µì‚¬ ë¹„ìš© ì œë¡œ
   - Unsafe ì½”ë“œ í•„ìš”

2. **Javaì˜ ì œì•½: ë³µì‚¬ í•„ìˆ˜**
   - Heap ë°°ì—´ì„ piní•  ìˆ˜ ì—†ìŒ
   - ëª¨ë“  ë°ì´í„°ë¥¼ Nativeë¡œ ë³µì‚¬í•´ì•¼ í•¨
   - Arena ì¬ì‚¬ìš©ìœ¼ë¡œ ì˜¤ë²„í—¤ë“œ ìµœì†Œí™” ê°€ëŠ¥

3. **ì„±ëŠ¥ ì°¨ì´**
   - ì‘ì€ í¬ê¸°(< 1KB): ë‘ ì–¸ì–´ ëª¨ë‘ ë¹„ìŠ· (< 100ns ì°¨ì´)
   - í° í¬ê¸°(> 64KB): C# Zero-copyê°€ ìš°ìœ„
   - ìµœì í™”ëœ Java ë³µì‚¬ë„ ì¶©ë¶„íˆ ë¹ ë¦„ (1MBì— 25Î¼s)

4. **ì‹¤ë¬´ ì„ íƒ ê¸°ì¤€**
   - ì½ê¸° ì „ìš© ëŒ€ìš©ëŸ‰ ë°ì´í„°: C# ìœ ë¦¬
   - ì•ˆì „ì„±ê³¼ íƒ€ì… ì•ˆì „: Java ìœ ë¦¬
   - ì„±ëŠ¥ ê·¹í•œ ìµœì í™”: C# ìœ ë¦¬
   - í¬ë¡œìŠ¤ í”Œë«í¼ ì¼ê´€ì„±: Java ìœ ë¦¬

### ìµœì¢… ê¶Œì¥ì‚¬í•­

**C# ê°œë°œì**:
- ê°€ëŠ¥í•˜ë©´ `fixed` ë˜ëŠ” `Span<T>`ë¡œ Zero-copy êµ¬í˜„
- ì‘ì€ í¬ê¸°ëŠ” `stackalloc`, í° í¬ê¸°ëŠ” `NativeMemory.Alloc`
- `Marshal.AllocHGlobal`ì€ ë ˆê±°ì‹œ ì½”ë“œì—ë§Œ ì‚¬ìš©

**Java ê°œë°œì**:
- ë ˆê±°ì‹œê°€ ì•„ë‹ˆë©´ DirectByteBuffer ëŒ€ì‹  MemorySegment ì‚¬ìš©
- Arenaë¥¼ ì¬ì‚¬ìš©í•˜ì—¬ í• ë‹¹ ì˜¤ë²„í—¤ë“œ ìµœì†Œí™”
- ëŒ€ìš©ëŸ‰ ë°ì´í„°ëŠ” ì²­í¬ ë‹¨ìœ„ë¡œ ì²˜ë¦¬í•˜ì—¬ ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± í™•ë³´

ë‘ ì–¸ì–´ ëª¨ë‘ í˜„ëŒ€ì ì´ê³  ê°•ë ¥í•œ ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬ APIë¥¼ ì œê³µí•©ë‹ˆë‹¤. í•µì‹¬ì€ ê° ì–¸ì–´ì˜ íŠ¹ì„±ì„ ì´í•´í•˜ê³ , ì‚¬ìš© ì‚¬ë¡€ì— ë§ëŠ” ìµœì ì˜ íŒ¨í„´ì„ ì„ íƒí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

---

**ê´€ë ¨ ìë£Œ**:
- [C# NativeMemory API ë¬¸ì„œ](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.nativememory)
- [Java Foreign Function & Memory API](https://openjdk.org/jeps/454)
- [ë²¤ì¹˜ë§ˆí¬ ì†ŒìŠ¤ ì½”ë“œ](https://github.com/ulala-x/ulala-x.github.io/tree/main/project/csharp-java-memory)
